VERSION  5

2017-11-27 09:23:49

实现了进程交互的基本功能,加入了 和 服务器端通信的基本功能

CHANGELOG:
	将普通进程做成了两个部分,一个作为库存在,一个就是 我们之后要写的 东西
	整理了 ws_client.c 



实现目标
	任意一个进程 A 能够 不 关心 连接的建立 ,但是能够 正常的 与 服务器端 的
	websocket 服务器 进行 通信 ,通信可靠,安全

实现思路
	实现 一个 ws_client 进程,作为后台进程 .
	其他 任意进程 A 通过与 ws_client 进程交互, 然后达到 不关心连接,但是能够与
	websocket 服务器 通信的目的


具体实现
	实现一个 ws_client 程序 ,对应的入口文件 为ws_client.c 文件 ,这个程序作为
	后台程序 运行

	实现一个 普通  的任意程序A ,可以通过 运行的时候 添加不同的参数 来 模仿 成为 一个
	独立的 进程, 程序 A 可以被多次加载 ,以实现 多个普通进程 和 ws_client 的交互
	

1/该目录下要实现 2个 进程 

这两个进程在 本地运行

	1/ws_client 进程
		1/线程 thread_main 处理 读入 server 端 的数据 //暂时 未
		实现,线程已经存在

		2/线程 thread_insert 能够 正常插入链表 //已经实现,暂时不需要修改

		3/线程 threed_del_list 能够 正常处理链表 //已经实现,还需要添加 发送函数
		    和 检查 状态(可以发送的状态)函数

               注意: 涉及两个进程,一个处理插入,一个处理发送是有必要的,因为
               发送线程并不能保证一开始就相应 普通进程的需求

	2/主机端进程  
		没有线程.一个进程
		实现了回调
		读的时候全部是阻塞.会读取 4 个 receive.
		需要加参数 /tmp/fifox

2/进程交互目标

	1/process 进程 发送数据给 ws_client 进程用的是 共享内存
	 对 共享资源的保护用的是线程的信号量

	2/ws_client 发送数据给 process 用的是 fifo 
	每个 process 维护一个fifo ,具体路径 在 运行的时候以参数的方式指定



3/ 进程交互信息

普通进程 -> ws_client

ws_client 创建的 共享内存内的数据
用 锁 和 状态来 控制 同步

消息类型,struct msg_send_t 

ws_client -> 普通进程

普通进程创建且维护的fifo 
用信号同步

消息类型,char *
               第一个字节 为 消息状态1(标识是第几次的回调信息 1.插入链表回调 2.发出回调 3.接收信息回调 4.主动消息回调)
               最后一个字节为 消息返回状态2(表示是否成功 类似的状态)
               第二个字节到'\0',标识加密信息.(匹配普通进程的N条发送消息中的一条)
               





TODO 这里面几乎没对函数的返回值进行验证,需要做
TODO ws_client.c 里面没有对fifo 写的保护,因为很可能客户端关闭fifo

TODO process.c 中没有对 共享内存 的验证,因为很有可能 服务端 的共享内存出问题






